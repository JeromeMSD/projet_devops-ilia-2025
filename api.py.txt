# api.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import datetime

from .database import SessionLocal
from .models import CSPRecord

router = APIRouter(prefix="/csp", tags=["CSP"])

# ---------- SCHEMAS Pydantic ----------

class CSPRecordIn(BaseModel):
    external_id: str
    timestamp: datetime
    value: float
    score: float | None = None
    quality: str | None = None


class CSPRecordOut(BaseModel):
    id: int
    external_id: str
    timestamp: datetime
    value: float
    score: float | None = None
    quality: str | None = None
    status: str

    class Config:
        orm_mode = True


# ---------- Dépendance DB ----------

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ---------- Endpoints ----------

@router.post("/ingest", response_model=List[CSPRecordOut])
def ingest_records(records: List[CSPRecordIn], db: Session = Depends(get_db)):
    """Enregistre une liste d'enregistrements déjà validés/traités."""
    db_records: List[CSPRecord] = []
    for r in records:
        obj = CSPRecord(
            external_id=r.external_id,
            timestamp=r.timestamp,
            value=r.value,
            status="processed" if r.quality else "raw",
        )
        # BONUS : stocker score / quality dans d'autres colonnes si tu les ajoutes au modèle
        db.add(obj)
        db_records.append(obj)

    db.commit()
    for obj in db_records:
        db.refresh(obj)

    return db_records


@router.get("/records", response_model=List[CSPRecordOut])
def list_records(limit: int = 100, db: Session = Depends(get_db)):
    """Retourne les enregistrements stockés."""
    return db.query(CSPRecord).limit(limit).all()


@router.get("/records/{record_id}", response_model=CSPRecordOut)
def get_record(record_id: int, db: Session = Depends(get_db)):
    rec = db.query(CSPRecord).filter(CSPRecord.id == record_id).first()
    if not rec:
        raise HTTPException(status_code=404, detail="Record not found")
    return rec

